import fs from "fs"
import { z, ZodError } from "zod"
import { Connection, PublicKey } from "@solana/web3.js"

/** Configuration schema & loader */
const MonitorConfigSchema = z.object({
  rpcUrl: z.string().url(),
  trackedAccounts: z.array(z.string().length(44, "Invalid account address")),
  pollingIntervalMs: z.number().positive(),
  maxEvents: z.number().int().positive(),
  thresholdLamports: z.number().int().nonnegative(),
})
type MonitorConfig = z.infer<typeof MonitorConfigSchema>

function loadConfig(path: string): MonitorConfig {
  const raw = JSON.parse(fs.readFileSync(path, "utf-8"))
  const result = MonitorConfigSchema.safeParse(raw)
  if (!result.success) {
    console.error(
      "[loadConfig] Validation errors:",
      result.error.errors.map((e) => `${e.path.join(".")}: ${e.message}`)
    )
    throw new Error("Invalid configuration")
  }
  console.info("[loadConfig] Loaded config", result.data)
  return result.data
}

/** Event type for highâ€‘value account activity */
interface AccountEvent {
  account: string
  signature: string
  lamports: number
  slot: number
  timestamp: number
}

/** Structured logger */
const logger = {
  info: (msg: string, meta: any = {}) =>
    console.log({ level: "info", timestamp: new Date().toISOString(), msg, ...meta }),
  warn: (msg: string, meta: any = {}) =>
    console.warn({ level: "warn", timestamp: new Date().toISOString(), msg, ...meta }),
  error: (msg: string, meta: any = {}) =>
    console.error({ level: "error", timestamp: new Date().toISOString(), msg, ...meta }),
}

/** AccountMonitor polls Solana accounts for large transactions */
class AccountMonitor {
  private connection: Connection
  private timer?: NodeJS.Timer
  private events: AccountEvent[] = []

  constructor(private config: MonitorConfig) {
    this.connection = new Connection(config.rpcUrl, "confirmed")
  }

  start(): void {
    logger.info("Starting AccountMonitor", { config: this.config })
    this.timer = setInterval(() => this.poll().catch((err) => {
      logger.error("Polling error", { error: err.message })
    }), this.config.pollingIntervalMs)

    // initial poll immediately
    this.poll().catch((err) => logger.error("Initial poll failed", { error: err.message }))
  }

  stop(): void {
    if (this.timer) clearInterval(this.timer)
    logger.info("Stopped AccountMonitor")
  }

  getEvents(): AccountEvent[] {
    return [...this.events]
  }

  private async poll(): Promise<void> {
    for (const acct of this.config.trackedAccounts) {
      let pubkey: PublicKey
      try {
        pubkey = new PublicKey(acct)
      } catch {
        logger.warn("Invalid account address, skipping", { account: acct })
        continue
      }

      let sigInfos
      try {
        sigInfos = await this.connection.getSignaturesForAddress(pubkey, { limit: 20 })
      } catch (err: any) {
        logger.warn("Failed to fetch signatures", { account: acct, error: err.message })
        continue
      }

      for (const { signature, slot, blockTime } of sigInfos) {
        let tx
        try {
          tx = await this.connection.getTransaction(signature, { commitment: "confirmed" })
        } catch (err: any) {
          logger.warn("Failed to fetch transaction", { signature, error: err.message })
          continue
        }
        const lamports = tx?.meta?.postBalances?.[1] ?? 0
        if (lamports >= this.config.thresholdLamports) {
          const event: AccountEvent = {
            account: acct,
            signature,
            lamports,
            slot,
            timestamp: blockTime ? blockTime * 1000 : Date.now(),
          }
          this.recordEvent(event)
        }
      }
    }
  }

  private recordEvent(evt: AccountEvent): void {
    this.events.push(evt)
    if (this.events.length > this.config.maxEvents) {
      this.events.shift()
      logger.warn("Dropped oldest event to respect maxEvents", { maxEvents: this.config.maxEvents })
    }
    logger.info("Recorded high-value event", evt)
  }
}

/** Entrypoint */
async function main() {
  let config: MonitorConfig
  try {
    config = loadConfig("./config.json")
  } catch (err: any) {
    logger.error("Failed to load config", { error: err.message })
    process.exit(1)
  }

  if (config.trackedAccounts.length === 0) {
    logger.error("No accounts to track; please add addresses in config.json")
    process.exit(1)
  }

  const monitor = new AccountMonitor(config)
  monitor.start()

  // Stop after 5 intervals, then print events
  setTimeout(() => {
    monitor.stop()
    console.log("Final events:", monitor.getEvents())
    process.exit(0)
  }, config.pollingIntervalMs * 5)
}

main().catch((err) => {
  logger.error("Unexpected error", { error: err.message })
  process.exit(1)
})
